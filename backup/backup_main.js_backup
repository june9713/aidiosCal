function getCurrentTime() {
    const KR_TIME_DIFF=9*60*60*1000;
    return new Date(Date.now() + KR_TIME_DIFF);
}
// 로깅 유틸리티 함수 수정
async function log(type, message, data = null) {
    const now = getCurrentTime();
    const timestamp = now.toISOString();
    const logMessage = `[${timestamp}] [${type}] ${message}`;
    
    switch(type) {
        case 'ERROR':
            console.error(logMessage, data || '');
            break;
        case 'WARN':
            console.warn(logMessage, data || '');
            break;
        case 'INFO':
            console.info(logMessage, data || '');
            break;
        case 'DEBUG':
            console.debug(logMessage, data || '');
            break;
        default:
            console.log(logMessage, data || '');
    }
}

// Global variables
let currentUser = null;
let schedules = [];
let showCompleted = true;
let completedOnly = false; // 완료된 일정만 보기 상태
let selectedUsers = new Set();
let tokenRefreshInterval = null;
let currentPage = 1;
let isLoading = false;
let hasMoreSchedules = true;
const SCHEDULES_PER_PAGE = 50;

// DOM Elements
const authContainer = document.getElementById('auth-container');
const loginForm = document.getElementById('login-form');
const registerForm = document.getElementById('register-form');
const showRegisterLink = document.getElementById('show-register');
const showLoginLink = document.getElementById('show-login');

// Event Listeners
document.addEventListener('DOMContentLoaded', () => {
    log('INFO', 'DOMContentLoaded 이벤트 발생');
    log('INFO', 'Application initialized');
    
    const token = localStorage.getItem('token');
    const userData = localStorage.getItem('userData');
    
    log('DEBUG', '저장된 데이터 확인', { 
        hasToken: !!token, 
        hasUserData: !!userData,
        tokenLength: token ? token.length : 0
    });
    
    if (token && userData) {
        log('DEBUG', 'Found stored token and user data');
        try {
            currentUser = JSON.parse(userData);
            log('DEBUG', 'Parsed user data', currentUser);
            fetchUserProfile(token);
        } catch (error) {
            log('ERROR', 'Failed to parse stored user data', error);
            clearSession();
        }
    } else {
        log('INFO', 'No stored session found - showing login form');
    }

    if (loginForm) loginForm.addEventListener('submit', handleLogin);
    if (registerForm) registerForm.addEventListener('submit', handleRegister);
    
    if (showRegisterLink) {
        showRegisterLink.addEventListener('click', (e) => {
            e.preventDefault();
            if(loginForm) loginForm.style.display = 'none';
            if(registerForm) registerForm.style.display = 'block';
        });
    }
    
    if (showLoginLink) {
        showLoginLink.addEventListener('click', (e) => {
            e.preventDefault();
            if(registerForm) registerForm.style.display = 'none';
            if(loginForm) loginForm.style.display = 'block';
        });
    }
});

// Session Management Functions
function clearSession() {
    log('INFO', 'clearSession 시작');
    localStorage.removeItem('token');
    localStorage.removeItem('userData');
    currentUser = null;
    if (tokenRefreshInterval) {
        clearInterval(tokenRefreshInterval);
        tokenRefreshInterval = null;
    }
    stopAlarmPolling(); // 알람 폴링 중지
    window.location.reload();
}

function logout() {
    if (confirm('로그아웃 하시겠습니까?')) {
        clearSession();
    }
}

function startTokenRefresh() {
    log('INFO', 'Starting token refresh interval');
    if (tokenRefreshInterval) clearInterval(tokenRefreshInterval);
    tokenRefreshInterval = setInterval(refreshToken, 365 * 24 * 60 * 60 * 1000);
}

async function refreshToken() {
    const token = localStorage.getItem('token');
    if (!token) {
        log('WARN', 'No token found for refresh');
        return;
    }
    try {
        const response = await fetch('/token/refresh', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            const data = await response.json();
            localStorage.setItem('token', data.access_token);
            log('INFO', 'Token refreshed successfully');
        } else {
            log('ERROR', 'Token refresh failed', { status: response.status });
            clearSession();
        }
    } catch (error) {
        log('ERROR', 'Token refresh error', error);
        clearSession();
    }
}

// Authentication Functions
async function handleLogin(e) {
    e.preventDefault();
    const username = document.getElementById('username').value;
    const password = document.getElementById('password').value;
    log('INFO', 'Login attempt', { username });
    try {
        const response = await fetch('/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`,
        });
        if (response.ok) {
            const data = await response.json();
            if (data.access_token) {
                localStorage.setItem('token', data.access_token);
                log('INFO', 'Login successful');
                await fetchUserProfile(data.access_token);
            } else {
                log('ERROR', 'No access token in response');
                alert('로그인에 실패했습니다. 서버 응답이 올바르지 않습니다.');
            }
        } else {
            const error = await response.json();
            // ... (error handling as before)
             if (response.status === 422) {
                log('ERROR', 'Login validation failed', error);
                const errorMessages = error.detail.map(
                    err => `[${err.loc ? err.loc.join('.') : ''}] ${err.msg}`
                );
                alert(`올바르지 않습니다:\n${errorMessages.join('\n')}`);
            } else {
                log('ERROR', 'Login failed', { status: response.status, error });
                alert(error.detail || '로그인에 실패했습니다. 사용자 이름과 비밀번호를 확인해주세요.');
            }
        }
    } catch (error) {
        log('ERROR', 'Login error', error);
        alert('로그인 중 오류가 발생했습니다.');
    }
}

async function handleRegister(e) {
    e.preventDefault();
    const username = document.getElementById('reg-username').value;
    const name = document.getElementById('reg-name').value;
    const password = document.getElementById('reg-password').value;
    const confirmPassword = document.getElementById('reg-confirm-password').value;

    if (!username || !name || !password || !confirmPassword) {
        alert('모든 필드를 입력해주세요.'); return;
    }
    if (password !== confirmPassword) {
        alert('비밀번호가 일치하지 않습니다.'); return;
    }
    try {
        const payload = { username, name, password };
        const response = await fetch('/register', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (response.ok) {
            alert('회원가입이 완료되었습니다. 로그인해주세요.');
            showLoginForm();
        } else {
            const errorData = await response.json();
            // ... (error handling as before)
            if (response.status === 422) {
                log('ERROR', 'Registration validation failed', errorData);
                const errorMessages = errorData.detail.map(
                    err => `[${err.loc ? err.loc.join('.') : ''}] ${err.msg}`
                );
                alert(`입력값이 올바르지 않습니다:\n${errorMessages.join('\n')}`);
            } else {
                log('ERROR', 'Registration failed', { status: response.status, error: errorData });
                alert(errorData.detail || '회원가입 중 오류가 발생했습니다.');
            }
        }
    } catch (error) {
        log('ERROR', 'Registration error', error);
        alert('회원가입 중 오류가 발생했습니다.');
    }
}

function showLoginForm() {
    if(registerForm) registerForm.style.display = 'none';
    if(loginForm) loginForm.style.display = 'block';
}

async function fetchUserProfile(token) {
    log('DEBUG', 'fetchUserProfile 시작', { token: token ? 'exists' : 'missing' });
    if (!token) { clearSession(); return; }
    try {
        const response = await fetch('/users/me', {
            headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
        });
        if (response.ok) {
            const userData = await response.json();
            currentUser = userData;
            localStorage.setItem('userData', JSON.stringify(currentUser));
            showScheduleInterface();
            await loadSchedules();
            startTokenRefresh();
            startAlarmPolling(); // 알람 폴링 시작
        } else if (response.status === 401) {
            log('ERROR', 'Unauthorized in fetchUserProfile');
            clearSession();
        } else {
            log('ERROR', 'Failed to fetch user profile', { status: response.status });
            clearSession();
        }
    } catch (error) {
        log('ERROR', 'Network or other error in fetchUserProfile', error);
        clearSession();
    }
}

// Schedule Interface Functions
function showScheduleInterface() {
    log('INFO', 'showScheduleInterface 시작');
    authContainer.innerHTML = `
        <details class="controls-collapsible">
            <summary class="controls-header">
                <h3>컨트롤</h3>
                <span class="toggle-icon">▼</span>
            </summary>
            <div class="controls">
                <button onclick="toggleCompletedFilter()">완료 일정 숨기기</button>
                <button onclick="toggleFileView()">파일 보기</button> 
                <button onclick="exportToExcel()" class="excel-export-btn">
                    <i class="fas fa-file-excel"></i> 엑셀로 출력
                </button>
                <button onclick="logout()" class="logout-btn">로그아웃</button>
            </div>
        </details>
        <details id="user-filter" class="user-filter-collapsible">
            <summary class="filter-header">
                <h3>사용자 필터</h3>
                <span class="toggle-icon">▼</span>
            </summary>
            <div class="filter-content">
                <div id="user-checkboxes"></div>
                <div class="schedule-info">
                    <span id="schedule-count">총 0개 일정</span>
                    <span id="loading-indicator" style="display: none;">로딩 중...</span>
                </div>
            </div>
        </details>
        <details id="alarm-collapsible" class="alarm-collapsible">
            <summary class="alarm-header-collapsible">
                <h3>알람</h3>
                <div class="alarm-header-actions">
                    <button onclick="clearAllAlarms()" class="clear-all-btn">모두 지우기</button>
                    <span class="toggle-icon">▼</span>
                </div>
            </summary>
            <div class="alarm-container">
                <div id="alarm-list"><div class="no-alarms">새로운 알람이 없습니다.</div></div>
            </div>
        </details>
        <button onclick="showAddScheduleForm()" class="add-schedule-btn">일정 추가</button>
        <div class="schedule-container" id="schedule-container">
            <table class="schedule-table">
                <thead><tr><th>날짜</th><th>작성자</th><th>제목</th></tr></thead>
                <tbody id="schedule-body"></tbody>
            </table>
        </div>
    `;
    loadUserCheckboxes();
    loadAlarms();
    setupInfiniteScroll();
    updateToggleCompletedButtonText();
    addDeleteAllButton(); // 모든 일정 삭제 버튼 추가
}

function setupInfiniteScroll() {
    const scheduleContainer = document.getElementById('schedule-container');
    if (!scheduleContainer) return;
    scheduleContainer.addEventListener('scroll', async () => {
        const { scrollTop, scrollHeight, clientHeight } = scheduleContainer;
        if (scrollTop + clientHeight >= scrollHeight * 0.9 && hasMoreSchedules && !isLoading) {
            currentPage++;
            showLoadingIndicator(true);
            await loadSchedules(currentPage, true); // append = true
            showLoadingIndicator(false);
        }
    });
}

function showLoadingIndicator(show) {
    const indicator = document.getElementById('loading-indicator');
    if (indicator) indicator.style.display = show ? 'inline' : 'none';
}

function updateScheduleCount() {
    const countElement = document.getElementById('schedule-count');
    if (countElement) {
        const visibleSchedules = schedules.filter(s => {
            if (!showCompleted && s.is_completed && !completedOnly) return false;
            if (completedOnly && !s.is_completed) return false;
            if (selectedUsers.size > 0 && !selectedUsers.has(s.owner_id)) return false;
            return true;
        });
        countElement.textContent = `표시: ${visibleSchedules.length}개 / 전체: ${schedules.length}개 (DB)`;
    }
}

async function refreshSchedules() {
    log('DEBUG', 'refreshSchedules 시작');
    currentPage = 1;
    hasMoreSchedules = true; // 더 많은 스케줄이 있을 수 있다고 가정
    // schedules = []; // 바로 비우지 않고, loadSchedules에서 append=false로 처리
    await loadSchedules(1, false); // append = false
}

function updateToggleCompletedButtonText() {
    const button = document.querySelector('.controls button:first-child');
    if (!button) return;
    if (completedOnly) {
        button.textContent = '진행 일정 보기';
    } else if (!showCompleted) {
        button.textContent = '완료 일정만 보기';
    } else {
        button.textContent = '완료 일정 숨기기';
    }
}

function toggleCompletedFilter() {
    if (showCompleted && !completedOnly) { // 현재: 완료일정 숨기기 버튼 (모든 일정 표시 중)
        showCompleted = true;
        completedOnly = true; // -> 완료 일정만 보기
    } else if (completedOnly) { // 현재: 완료 일정만 보기 버튼
        showCompleted = true;
        completedOnly = false; // -> 모든 일정 보기 (완료일정 숨기기 버튼으로)
    } else { // 현재: 완료 일정만 보기 버튼 (진행 일정만 표시 중 - !showCompleted)
        showCompleted = false; // -> 완료 일정 숨기기 (이 상태는 showCompleted = false)
        completedOnly = false; // 이 상태에서 버튼을 누르면 '완료일정만 보기'로 가야하므로
                               // showCompleted = true, completedOnly = true 로 변경되어야 함.
                               // 하지만, 바로 위에서 처리하므로, 여기서는 showCompleted = true, completedOnly = false 로 가서 모든 일정을 보여주는 것으로.
                               // 다시 생각: 이 버튼은 3단 토글.
                               // 1. 완료일정 숨기기 (모두 보임, showCompleted=true, completedOnly=false)
                               // 2. 완료일정만 보기 (완료만 보임, showCompleted=true, completedOnly=true)
                               // 3. 진행일정만 보기 (진행만 보임, showCompleted=false, completedOnly=false)
        // 이 로직을 단순화 필요. 백엔드 파라미터를 직접 사용.
        // 현재 상태: (showCompleted=true, completedOnly=false) -> '완료일정 숨기기'
        // 다음 상태: (showCompleted=true, completedOnly=true) -> '완료일정만 보기' (버튼텍스트: 진행일정 보기)
        // 다음 상태: (showCompleted=false, completedOnly=false) -> '진행일정만 보기' (버튼텍스트: 완료일정 보기)

        // 3-state toggle: All -> Completed Only -> In-Progress Only -> All
        if (showCompleted && !completedOnly) { // State 1: All shown, button "완료 숨기기"
            // Go to State 2: Completed Only
            completedOnly = true;
        } else if (showCompleted && completedOnly) { // State 2: Completed Only shown, button "진행 보기"
            // Go to State 3: In-Progress Only
            showCompleted = false;
            completedOnly = false;
        } else if (!showCompleted && !completedOnly) { // State 3: In-Progress Only shown, button "완료 보기"
            // Go to State 1: All
            showCompleted = true;
            completedOnly = false;
        }
    }
    updateToggleCompletedButtonText();
    refreshSchedules();
}


function toggleFileView() {
    const scheduleTable = document.querySelector('.schedule-container .schedule-table');
    const fileListView = document.querySelector('.schedule-container .file-list-view');
    const button = document.querySelector('.controls button:nth-child(3)');


    if (scheduleTable && scheduleTable.style.display !== 'none') { // 일정 보기 상태 -> 파일 보기로
        if (fileListView) {
            scheduleTable.style.display = 'none';
            fileListView.style.display = 'block';
        } else {
            showFileView(); // 처음이면 생성
        }
        if(button) button.textContent = '일정 보기';
    } else { // 파일 보기 상태 -> 일정 보기로
        if (scheduleTable) {
            scheduleTable.style.display = 'table'; // table로 display 복원
             if (fileListView) fileListView.style.display = 'none';
        }
        if(button) button.textContent = '파일 보기';
    }
}

async function showFileView() {
    const container = document.querySelector('.schedule-container');
    if (!container) return;
    
    const scheduleTable = container.querySelector('.schedule-table');
    if (scheduleTable) scheduleTable.style.display = 'none';

    let fileListView = container.querySelector('.file-list-view');
    if (!fileListView) {
        fileListView = document.createElement('div');
        fileListView.className = 'file-list-view'; // 새 클래스 이름
        fileListView.innerHTML = `<div class="file-list" id="file-list-main"></div>`; // ID 변경
        container.appendChild(fileListView);
    }
    fileListView.style.display = 'block';
    await loadFilesForMainView(); // 새 함수 호출
}

async function loadFilesForMainView() { // 새 함수
    try {
        const token = localStorage.getItem('token');
        if (!token) return;
        // API 엔드포인트가 /schedules/attachments 인지 /getschedules/-1 인지 확인 필요. 백업에서는 /schedules/attachments 사용.
        const response = await fetch('/schedules/attachments', { 
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            const files = await response.json();
            renderFilesForMainView(files); // 새 함수 호출
        } else {
            log('ERROR', 'Failed to load files for main view', {status: response.status});
            const fileListMain = document.getElementById('file-list-main');
            if(fileListMain) fileListMain.innerHTML = '<p class="no-files">파일 목록을 불러오는데 실패했습니다.</p>';
        }
    } catch (error) {
        log('ERROR', 'File load error for main view', error);
        const fileListMain = document.getElementById('file-list-main');
        if(fileListMain) fileListMain.innerHTML = '<p class="no-files">파일 목록 로딩 중 오류 발생.</p>';
    }
}

function renderFilesForMainView(files) { // 새 함수
    const fileListMain = document.getElementById('file-list-main');
    if (!fileListMain) return;
    fileListMain.innerHTML = '';
    if (files.length === 0) {
        fileListMain.innerHTML = '<p class="no-files">첨부된 파일이 없습니다.</p>';
        return;
    }
    files.forEach(file => {
        const li = document.createElement('li');
        li.className = 'file-item';
        const createdDate = new Date(file.created_at).toLocaleString('ko-KR');
        li.innerHTML = `
            <div class="file-info">
                <span class="file-name">${file.file_name}</span>
                <span class="file-type">${file.file_type}</span>
                <span class="file-size">${formatFileSize(file.file_size || 0)}</span>
                <span class="file-date">${createdDate}</span>
                ${file.schedule_title ? `<span class="file-schedule">관련 일정: ${file.schedule_title}</span>` : ''}
            </div>
            <div class="file-actions">
                <button onclick="downloadFile('${file.file_path}')">다운로드</button>
                <button onclick="deleteFileFromMainView(${file.id})">삭제</button> 
            </div>
        `;
        fileListMain.appendChild(li);
    });
}

async function deleteFileFromMainView(fileId) { // 새 함수
    if (!confirm('정말로 이 파일을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) return;
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        const response = await fetch(`/schedules/attachments/${fileId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            await loadFilesForMainView(); // 파일 목록 새로고침
        } else {
            const error = await response.json();
            log('ERROR', 'Failed to delete file from main view', error);
            alert(error.detail || '파일 삭제에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'File delete error from main view', error);
        alert('파일 삭제 중 오류가 발생했습니다.');
    }
}


async function loadSchedules(page = 1, append = false) {
    if (isLoading && append) return; // 추가 로드 중이면 중복 방지
    isLoading = true;
    showLoadingIndicator(true);

    const token = localStorage.getItem('token');
    if (!token) { clearSession(); isLoading = false; showLoadingIndicator(false); return; }

    const params = new URLSearchParams({
        skip: (page - 1) * SCHEDULES_PER_PAGE,
        limit: SCHEDULES_PER_PAGE,
    });
    // 필터링 조건 추가
    if (completedOnly) {
        params.append('completed_only', 'true');
    } else {
        params.append('show_completed', showCompleted.toString());
    }

    if (selectedUsers.size > 0) {
        selectedUsers.forEach(userId => params.append('user_ids', userId));
    }
    
    log('DEBUG', `Requesting schedules from: /schedules/?${params.toString()}`);

    try {
        const response = await fetch(`/schedules/?${params.toString()}`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            const data = await response.json(); // FastAPI가 객체 {schedules: [], total_count: N}를 반환한다고 가정
            const newSchedules = data.schedules || (Array.isArray(data) ? data : []); // 호환성
            
            if (append) {
                schedules = schedules.concat(newSchedules);
            } else {
                schedules = newSchedules;
            }
            hasMoreSchedules = newSchedules.length === SCHEDULES_PER_PAGE;
            renderSchedules();
        } else if (response.status === 401) {
            clearSession();
        } else {
            log('ERROR', 'Failed to load schedules', {status: response.status});
        }
    } catch (error) {
        log('ERROR', 'Network or other error in loadSchedules', error);
    } finally {
        isLoading = false;
        showLoadingIndicator(false);
        updateScheduleCount();
    }
}

function renderSchedules() {
    const tbody = document.getElementById('schedule-body');
    if (!tbody) return;

    const fragment = document.createDocumentFragment();
    schedules.forEach(schedule => {
        // 클라이언트 사이드 필터링 (선택 사항, 백엔드 필터링이 주력)
        if (completedOnly && !schedule.is_completed) return;
        if (!showCompleted && schedule.is_completed && !completedOnly) return;
        if (selectedUsers.size > 0 && !selectedUsers.has(schedule.owner_id)) return;

        const tr = document.createElement('tr');
        tr.className = schedule.is_completed ? 'completed' : '';
        tr.dataset.scheduleId = schedule.id; // data-schedule-id 속성 추가
        
        const priorityClassMap = { '긴급': 'priority-urgent', '급함': 'priority-high', '곧임박': 'priority-medium', '일반': 'priority-low', '거북이': 'priority-turtle'};
        if (!schedule.is_completed && schedule.priority) {
            tr.classList.add(priorityClassMap[schedule.priority] || 'priority-low');
        }

        const dueTime = schedule.due_time ? new Date(schedule.due_time) : null;
        const now = getCurrentTime();
        if (dueTime && dueTime < now && !schedule.is_completed) {
            tr.classList.add('overdue');
        }
        
        function formatDateToMonthDay(dateStr) {
            //console.log('formatDateToMonthDay input:', dateStr);
            if (!dateStr) return '';
            const date = new Date(dateStr);
            //console.log('Parsed date:', date);
            const year = date.getFullYear().toString().slice(-2);
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const seconds = date.getSeconds().toString().padStart(2, '0');
            const result = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
            //console.log('Formatted result:', result);
            return result;
        }
        function formatPriorityIcon(priority) {
            return priority === '거북이' ? '🐢' : (priorityMap[priority] || priority || '');
        }
        const priorityMap = {'긴급':'🔥', '급함':'❗', '곧임박':'⚠️', '일반':'✉️', '거북이':'🐢'};

        // parent_order가 있으면 제목 앞에 추가
        const titlePrefix = typeof schedule.parent_order !== 'undefined' ? `(${schedule.parent_order}) ` : '';
        const displayTitle = `${titlePrefix}${schedule.title}`;

        // 날짜는 날짜와 마감시간, 초까지 모두 표시 현재는 초가 표시 안됨
        tr.innerHTML = `
            <td data-label="날짜">${schedule.due_time ? formatDateToMonthDay(schedule.due_time) : formatDateToMonthDay(schedule.date)}</td>
            <td data-label="작성자">${schedule.owner ? schedule.owner.name : '알수없음'}</td>
            <td data-label="제목">${formatPriorityIcon(schedule.priority)} ${displayTitle}</td>
        `;
        tr.addEventListener('click', () => handleScheduleClick(schedule)); // 변경된 함수 호출
        
        // 컨텍스트 메뉴 (우클릭 또는 길게 누르기)
        tr.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showContextMenu(e, schedule);
        });
        // (터치 이벤트 리스너 추가 필요)
        let touchTimer;
        tr.addEventListener('touchstart', (e) => {
            touchTimer = setTimeout(() => {
                e.preventDefault(); // 기본 동작 방지 (예: 텍스트 선택)
                showContextMenu(e.touches[0], schedule);
            }, 700); // 700ms 길게 터치
        });
        tr.addEventListener('touchend', () => clearTimeout(touchTimer));
        tr.addEventListener('touchmove', () => clearTimeout(touchTimer));


        fragment.appendChild(tr);
    });
    tbody.innerHTML = ''; // 기존 내용 삭제
    tbody.appendChild(fragment);
    updateScheduleCount();
}


function showContextMenu(event, schedule) {
    hideContextMenu(); // 기존 메뉴 제거
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.innerHTML = `
        <div class="context-menu-item" onclick="showMemoPopup(${schedule.id})">메모추가/수정</div>
        <div class="context-menu-item" onclick="requestCompletion(${schedule.id})">완료 요청</div>
        <div class="context-menu-item" onclick="handleScheduleClick(${JSON.stringify(schedule).replace(/"/g, '&quot;')})">상세보기/수정</div>
    `;

    document.body.appendChild(menu);
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    let x = event.clientX || event.pageX;
    let y = event.clientY || event.pageY;

    if (x + menuWidth > window.innerWidth) {
        x = window.innerWidth - menuWidth - 5;
    }
    if (y + menuHeight > window.innerHeight) {
        y = window.innerHeight - menuHeight - 5;
    }
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    
    // 모바일 터치 이벤트 처리 개선
    menu.addEventListener('touchstart', (e) => {
        e.stopPropagation(); // 이벤트 전파 중단
    }, { passive: false });
    
    // 메뉴 아이템에 대한 터치 이벤트 처리
    const menuItems = menu.querySelectorAll('.context-menu-item');
    menuItems.forEach(item => {
        item.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: false });
    });
    
    // 메뉴 외부 터치 시 메뉴 닫기
    setTimeout(() => {
        document.addEventListener('touchstart', hideContextMenu, { once: true });
    }, 0);
}

function hideContextMenu() {
    const menu = document.querySelector('.context-menu');
    if (menu) menu.remove();
    document.removeEventListener('click', hideContextMenu);
    document.removeEventListener('touchstart', hideContextMenu);
}


async function requestCompletion(scheduleId) {
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        const response = await fetch(`/schedules/${scheduleId}/request-completion`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }
        });
        if (response.ok) {
            alert('완료 요청이 전송되었습니다.');
        } else if (response.status === 404 ) { // FastAPI에서 해당 기능 미구현 시 404 반환 가정
            alert('완료 요청 기능이 아직 지원되지 않습니다.');
        } else {
            const error = await response.json();
            alert(error.detail || '완료 요청 전송에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Request completion error', error);
        alert('완료 요청 중 오류가 발생했습니다.');
    }
    hideContextMenu();
}


// --- MODAL RELATED FUNCTIONS ---
// Replaces showScheduleDetail, creates structure expected by editSchedule
function handleScheduleClick(schedule) {
    closeScheduleModal(); // Close any existing modal
 
    const modal = document.createElement('div');
    modal.className = 'schedule-modal';
    modal.dataset.scheduleId = schedule.id; // For deleteAttachment
    if (typeof schedule.parent_order !== 'undefined') {
        modal.dataset.parentOrder = schedule.parent_order;
    }
 
    // 부모 일정 정보 저장
    window.lastParentTitle = schedule.title;
    window.lastParentContent = schedule.content;
    window.lastParentProjectName = schedule.project_name;
    window.lastParentPriority = schedule.priority;
 
    function formatDateModal(dateStr) {
        if (!dateStr) return '없음';
        return new Date(dateStr).toLocaleString('ko-KR', {
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', second: '2-digit'
        });
    }
 
    modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h2>${schedule.title}</h2>
                <button onclick="closeDetail()" class="close-button">×</button>
            </div>
            <div class="modal-body">
                <div class="schedule-detail">
                    <div class="schedule-info-table">
                        <div class="schedule-info-label">프로젝트명</div>
                        <div class="schedule-info-value">${schedule.project_name || '일정'}</div>
                        <div class="schedule-info-label">일정명</div>
                        <div class="schedule-info-value">${schedule.title || '일정'}</div>
                        <div class="schedule-info-label">작성자</div>
                        <div class="schedule-info-value">${schedule.owner ? schedule.owner.name : '알 수 없음'}</div>
                        
                        <div class="schedule-info-label">부모작업</div>
                        <div class="schedule-info-value">
                            ${schedule.parent ? schedule.parent.title : '없음'}
                        </div>
                        
                        <div class="schedule-info-label">날짜</div>
                        <div class="schedule-info-value">${formatDateModal(schedule.date)}</div>
                        
                        <div class="schedule-info-label">우선순위</div>
                        <div class="schedule-info-value">
                            <span class="priority-display priority-${schedule.priority || 'none'}">
                                ${schedule.priority || '없음'}
                            </span>
                        </div>
                        
                        <div class="schedule-info-label">마감시간</div>
                        <div class="schedule-info-value">${formatDateModal(schedule.due_time)}</div>
                        
                        <div class="schedule-info-label">알람시간</div>
                        <div class="schedule-info-value">${formatDateModal(schedule.alarm_time)}</div>
                        
                        <div class="schedule-info-label">상태</div>
                        <div class="schedule-info-value">
                            <span class="${schedule.is_completed ? 'status-completed' : 'status-pending'}">
                                ${schedule.is_completed ? '완료' : '미완료'}
                            </span>
                        </div>
                        
                        <div class="schedule-info-label">내용</div>
                        <div class="schedule-info-value">
                            <div class="schedule-content-display">
                                ${schedule.content ? schedule.content.replace(/\n/g, '<br>') : '없음'}
                            </div>
                        </div>
                    </div>
                    
                    <div class="attachments-section">
                        <div class="attachments-header">첨부 파일</div>
                        <div class="file-upload">
                            <input type="file" id="modal-file-upload" multiple>
                            <button onclick="uploadFilesToSchedule(${schedule.id})">업로드</button>
                        </div>
                        <div id="modal-attachments-list"></div>
                    </div>
                    
                    <div class="schedule-actions">
                        <button onclick="editSchedule(${schedule.id})">수정</button>
                        <button onclick="shareSchedule(${schedule.id})">공유</button>
                        <button onclick="toggleComplete(${schedule.id}, ${!schedule.is_completed})">
                            ${schedule.is_completed ? '미완료로' : '완료로'}
                        </button>
                        <button onclick="deleteSchedule(${schedule.id})" class="clear-all-btn">삭제</button>
                        <button onclick="createChildSchedule(${schedule.id})">후속작업 생성</button>
                        ${schedule.parent ? `<button onclick="viewParentSchedule(${schedule.parent.id})">부모작업 보기</button>` : ''}
                        ${schedule.children && schedule.children.length > 0 ? `<button onclick="viewChildrenSchedules(${schedule.id})">후속작업 보기</button>` : ''}
                    </div>
                    <div class="memo-section">
                        <div class="memo-header">메모</div>
                        <div class="memo-container">
                            ${schedule.memo ? schedule.memo.split('\n').map(line => `<div class="memo-line">${line}</div>`).join('') : '<div class="memo-line">없음</div>'}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    loadAttachmentsForModal(schedule.id);
}

// 후속 작업 관련 함수들
async function createChildSchedule(parentId) {
    try {
        // 1. 상세 모달에서 parentOrder 값을 미리 읽어둠
        const parentModal = document.getElementsByClassName('schedule-modal')[0];
        const parent_order = parentModal ? Number(parentModal.dataset.parentOrder) : 0;
        const childCount = parent_order + 1;

        // 2. 상세 모달 닫기
        closeScheduleModal();

        // 3. 일정 추가 폼 띄우기
        showAddScheduleForm();

        // 4. 폼이 렌더링된 후 값을 세팅
        setTimeout(() => {
            // 제목은 비워두고 placeholder만 표시
            document.getElementById('schedule-title').value = '';
            document.getElementById('schedule-content').value = window.lastParentContent || '';
            document.getElementById('schedule-project').value = window.lastParentProjectName || '';
            // 부모 프로젝트 정보 표시
            const parentInfoDiv = document.getElementById('schedule-parent-info');
            if (parentInfoDiv) {
                parentInfoDiv.textContent = window.lastParentTitle || '없음';
            }
            // 현재 날짜로 설정
            const now = getCurrentTime();
            const nowDate = now.toISOString().split('T')[0];
            document.getElementById('schedule-date').value = nowDate;
            document.getElementById('schedule-priority').value = window.lastParentPriority || '일반';
            
            // 부모 ID와 parent_order를 hidden input으로 저장
            const form = document.getElementById('internal-add-schedule-form');
            if (form) {
                let parentIdInput = form.querySelector('#parent-id');
                if (!parentIdInput) {
                    parentIdInput = document.createElement('input');
                    parentIdInput.type = 'hidden';
                    parentIdInput.id = 'parent-id';
                    form.appendChild(parentIdInput);
                }
                parentIdInput.value = parentId;

                let parentOrderInput = form.querySelector('#parent-order');
                if (!parentOrderInput) {
                    parentOrderInput = document.createElement('input');
                    parentOrderInput.type = 'hidden';
                    parentOrderInput.id = 'parent-order';
                    form.appendChild(parentOrderInput);
                }
                parentOrderInput.value = childCount;
            }
        }, 100);
    } catch (error) {
        console.error('Create child schedule error:', error);
        alert(error.message);
    }
}

function closeDetail() {

    const detailDiv = document.querySelector('.schedule-modal');
    
    if (detailDiv) {
    
    detailDiv.remove();
    
    }
    
}

function closeScheduleModal() {
    const modal = document.querySelector('.schedule-modal');
    if (modal) {
        modal.remove();
    }
}

// --- ATTACHMENT FUNCTIONS FOR MODAL ---
async function loadAttachmentsForModal(scheduleId) {
    const token = localStorage.getItem('token');
    if (!token) return;
    const attachmentsList = document.getElementById('modal-attachments-list');
    if (!attachmentsList) return;
    attachmentsList.innerHTML = '<p>첨부 파일 로딩 중...</p>';

    try {
        // 스케줄 상세 정보를 가져와서 attachments를 얻어야 함
        const response = await fetch(`/schedules/${scheduleId}`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            const scheduleData = await response.json();
            renderAttachmentsForModal(scheduleData.attachments || [], scheduleId);
        } else {
            log('ERROR', 'Failed to load schedule details for attachments', {status: response.status});
            attachmentsList.innerHTML = '<p>첨부 파일을 불러오는데 실패했습니다.</p>';
        }
    } catch (error) {
        log('ERROR', 'Load attachments error for modal', error);
        attachmentsList.innerHTML = '<p>첨부 파일 로딩 중 오류 발생.</p>';
    }
}

function renderAttachmentsForModal(attachments, scheduleId) {
    const attachmentsList = document.getElementById('modal-attachments-list');
    if (!attachmentsList) return;
    attachmentsList.innerHTML = '';
    if (attachments.length === 0) {
        attachmentsList.innerHTML = '<p>첨부된 파일이 없습니다.</p>';
        return;
    }
    attachments.forEach(attachment => {
        const attachmentDiv = document.createElement('div');
        attachmentDiv.className = 'attachment-item';
        attachmentDiv.innerHTML = `
            <div class="attachment-info">
                <a href="${attachment.file_path}" target="_blank" download="${attachment.file_name || 'download'}">
                  <span class="attachment-name">${attachment.file_name}</span>
                </a>
                <span class="attachment-size">${formatFileSize(attachment.file_size || 0)}</span>
            </div>
            <button onclick="deleteAttachmentFromModal(${attachment.id}, ${scheduleId})" class="delete-btn">삭제</button>
        `;
        attachmentsList.appendChild(attachmentDiv);
    });
}

async function uploadFilesToSchedule(scheduleId) {
    const token = localStorage.getItem('token');
    if (!token) return;
    const fileInput = document.getElementById('modal-file-upload');
    if (!fileInput || !fileInput.files.length) {
        alert('업로드할 파일을 선택해주세요.');
        return;
    }
    const formData = new FormData();
    for (const file of fileInput.files) {
        formData.append('file', file); // FastAPI에서는 List[UploadFile] = File(...) 이므로 'files'
    }
    try {
        const response = await fetch(`/schedules/${scheduleId}/attachments`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` }, // Content-Type은 FormData가 자동 설정
            body: formData
        });
        if (response.ok) {
            await loadAttachmentsForModal(scheduleId); // 목록 새로고침
            fileInput.value = ''; // 입력 필드 초기화
            alert('파일이 성공적으로 업로드되었습니다.');
        } else {
            const error = await response.json();
            log('ERROR', 'File upload to schedule failed', error);
            alert(error.detail || '파일 업로드에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'File upload to schedule error', error);
        alert('파일 업로드 중 오류가 발생했습니다.');
    }
}

async function deleteAttachmentFromModal(attachmentId, scheduleId) {
    if (!confirm('정말로 이 첨부 파일을 삭제하시겠습니까?')) return;
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        // API 엔드포인트는 /schedules/attachments/{attachment_id} 또는 /attachments/{attachment_id} 일 수 있음.
        // 백업에서는 /schedules/attachments/{id} 였음.
        const response = await fetch(`/schedules/attachments/${attachmentId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            await loadAttachmentsForModal(scheduleId); // 목록 새로고침
            alert('첨부 파일이 삭제되었습니다.');
        } else {
            const error = await response.json();
            log('ERROR', 'Failed to delete attachment from modal', error);
            alert(error.detail || '첨부 파일 삭제에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Delete attachment error from modal', error);
        alert('첨부 파일 삭제 중 오류가 발생했습니다.');
    }
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}


// --- SCHEDULE CRUD FUNCTIONS (ADD, EDIT, DELETE, COMPLETE, SHARE, MEMO from backup) ---
async function toggleComplete(scheduleId, completed) { // completed 파라미터는 현재 상태의 반대.
    log('DEBUG', 'Toggling schedule completion', { scheduleId, toState: completed });
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        // API가 is_completed 값을 받는지, 아니면 그냥 토글인지 확인 필요.
        // FastAPI에서는 보통 PUT /schedules/{id}/complete 또는 /schedules/{id}/incomplete
        // 또는 POST /schedules/{id}/toggle_complete
        // 여기서는 POST /schedules/{id}/complete 가 토글 역할을 한다고 가정 (백업과 동일)
        const response = await fetch(`/schedules/${scheduleId}/complete`, {
            method: 'POST', // 또는 PUT
            headers: { 'Authorization': `Bearer ${token}` /*, 'Content-Type': 'application/json' */},
            // body: JSON.stringify({ is_completed: completed }) // API가 상태를 받는 경우
        });
        if (response.ok) {
            log('INFO', 'Schedule completion toggled successfully');
            // 모달이 열려있으면 모달 내 정보 업데이트, 아니면 목록 새로고침
            const modal = document.querySelector('.schedule-modal');
            if (modal && modal.dataset.scheduleId == scheduleId) {
                 // 특정 스케줄 데이터만 다시 로드하여 모달 업데이트
                const updatedScheduleData = await response.json(); // API가 업데이트된 스케줄 반환 가정
                const scheduleIndex = schedules.findIndex(s => s.id === scheduleId);
                if (scheduleIndex !== -1) schedules[scheduleIndex] = updatedScheduleData;
                handleScheduleClick(updatedScheduleData); // 모달 다시 그리기
            } else {
                 await refreshSchedules(); // 전체 목록 새로고침
            }
        } else {
            const error = await response.json();
            log('ERROR', 'Failed to toggle schedule completion', error);
            alert(error.detail || '일정 상태 변경에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Toggle complete error', error);
        alert('일정 상태 변경 중 오류가 발생했습니다.');
    }
}

async function showAddScheduleForm() {
    // 기존 폼이 있으면 제거
    cancelAddSchedule();

    const now = getCurrentTime();
    const nowDate = now.toISOString().split('T')[0];
    const nowDateTime = now.toISOString().slice(0, 16);

    const formDiv = document.createElement('div');
    formDiv.className = 'add-schedule-form';

    formDiv.style.position = 'fixed';
    formDiv.style.top = '0';
    formDiv.style.left = '0';
    formDiv.style.width = '100vw';
    formDiv.style.height = '100vh';
    formDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
    formDiv.style.zIndex = '1000';
    formDiv.style.display = 'flex';
    formDiv.style.justifyContent = 'center';
    formDiv.style.alignItems = 'center';
    formDiv.style.padding = '20px';
    formDiv.style.boxSizing = 'border-box';

    formDiv.innerHTML = `
        <form id="internal-add-schedule-form" style="background-color: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); max-width: 500px; width: 100%; max-height: 90vh; overflow-y: auto; box-sizing: border-box;">
            <h3 style="text-align: center; margin-top: 0; margin-bottom: 20px; color: #333;">새 일정 추가</h3>
            
            <div class="form-group" style="position: relative;">
                <label for="schedule-project">프로젝트명 *</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="schedule-project" placeholder="프로젝트명을 입력하세요 (미입력시 '일정'으로 표시)" style="flex: 1;">
                    <button type="button" onclick="toggleProjectList()" style="padding: 5px 10px;">▼</button>
                </div>
                <div id="project-list" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-radius: 4px; max-height: 200px; overflow-y: auto; z-index: 1000;"></div>
            </div>

            <div class="form-group">
                <label for="schedule-title">제목 *</label>
                <input type="text" id="schedule-title" placeholder="제목을 입력하세요 (미입력시 '일정'으로 표시)">
            </div>

            <div class="form-group">
                <label for="schedule-parent">부모작업</label>
                <div id="schedule-parent-info" style="">
                    없음
                </div>
            </div>

            <div class="form-group">
                <label for="schedule-date">날짜 *</label>
                <input type="date" id="schedule-date" value="${nowDate}" required>
            </div>

            <div class="form-group">
                <label for="schedule-priority">우선순위 *</label>
                <select id="schedule-priority" required>
                    <option value="긴급">긴급</option>
                    <option value="급함">급함</option>
                    <option value="곧임박">곧임박</option>
                    <option value="일반" selected>일반</option>
                    <option value="거북이">🐢 거북이</option>
                </select>
            </div>

            <div class="form-group">
                <label for="schedule-content">내용</label>
                <textarea id="schedule-content" placeholder="내용" rows="3"></textarea>
            </div>

            <div class="form-group">
                <label for="schedule-due-time">마감시간</label>
                <input type="datetime-local" id="schedule-due-time" value="${nowDateTime}" step="1">
            </div>

            <div class="form-group">
                <label for="schedule-alarm-time">알람시간</label>
                <input type="datetime-local" id="schedule-alarm-time" value="${nowDateTime}" step="1">
            </div>

            <div class="form-group">
                <label>알람 빠른 설정</label>
                <div class="alarm-quick-buttons">
                    <button type="button" onclick="setQuickAlarmTime(1)">1시간 전</button>
                    <button type="button" onclick="setQuickAlarmTime(3)">3시간 전</button>
                    <button type="button" onclick="setQuickAlarmTime(24)">하루 전</button>
                    <button type="button" id="repeat-toggle" onclick="toggleRepeatInForm()">매일 반복</button>
                    <input type="hidden" id="schedule-repeat" value="false">
                </div>
            </div>

            <div class="form-buttons" style="text-align: right; margin-top: 20px;">
                <button type="submit">추가</button>
                <button type="button" onclick="cancelAddSchedule()" style="padding: 10px 15px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">취소</button>
            </div>
        </form>
    `;

    document.body.appendChild(formDiv);

    const internalForm = formDiv.querySelector('#internal-add-schedule-form');
    if(internalForm) {
        internalForm.addEventListener('submit', handleAddSchedule);
        const dateInput = internalForm.querySelector('#schedule-date');
        if(dateInput) {
            dateInput.addEventListener('change', updateTimesOnDateChangeInForm);
        }
    }

    const firstInput = formDiv.querySelector('#schedule-project');
    if (firstInput) {
        firstInput.focus();
    }

    // 프로젝트 목록 로드
    await loadProjectList();
}

function toggleProjectList() {
    const projectList = document.getElementById('project-list');
    if (projectList) {
        projectList.style.display = projectList.style.display === 'none' ? 'block' : 'none';
    }
}

// 프로젝트 입력 필드 외부 클릭 시 드롭다운 닫기
document.addEventListener('click', (e) => {
    const projectList = document.getElementById('project-list');
    const projectInput = document.getElementById('schedule-project');
    const toggleButton = e.target.closest('button[onclick="toggleProjectList()"]');
    
    if (projectList && projectList.style.display !== 'none' && 
        !projectList.contains(e.target) && 
        !projectInput.contains(e.target) && 
        !toggleButton) {
        projectList.style.display = 'none';
    }
});

async function updateTimesOnDateChangeInForm() {
    const selectedDate = document.getElementById('schedule-date').value;
    if (!selectedDate) return;
    const now = getCurrentTime();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    const newDateTime = `${selectedDate}T${hours}:${minutes}:${seconds}`;
    const dueTimeInput = document.getElementById('schedule-due-time');
    const alarmTimeInput = document.getElementById('schedule-alarm-time');
    if (dueTimeInput) dueTimeInput.value = newDateTime;
    if (alarmTimeInput) alarmTimeInput.value = newDateTime;
}

async function setQuickAlarmTime(hoursBefore) {
    console.log('setQuickAlarmTime0', hoursBefore);
    const dueTimeInput = document.getElementById('schedule-due-time');
    const alarmTimeInput = document.getElementById('schedule-alarm-time');
    if (!dueTimeInput || !alarmTimeInput || !dueTimeInput.value) {
        alert('먼저 마감시간을 설정해주세요.'); return;
    }
    
    // 마감시간을 Date 객체로 변환
    console.log('setQuickAlarmTime1', dueTimeInput);
    const dueTime = new Date(dueTimeInput.value);
    if (isNaN(dueTime.getTime())) { 
        alert('유효한 마감시간을 설정해주세요.'); 
        return; 
    }
    
    // 알람 시간 계산 (마감시간에서 hoursBefore 시간을 뺌)
    const alarmTime = new Date(dueTime.getTime() - (hoursBefore * 60 * 60 * 1000));
    console.log('setQuickAlarmTime2', alarmTime);
    
    // datetime-local 입력 필드 형식으로 변환 (YYYY-MM-DDTHH:mm)
    const year = alarmTime.getFullYear();
    const month = String(alarmTime.getMonth() + 1).padStart(2, '0');
    const day = String(alarmTime.getDate()).padStart(2, '0');
    const hours = String(alarmTime.getHours()).padStart(2, '0');
    const minutes = String(alarmTime.getMinutes()).padStart(2, '0');
    const alarmDateTime = `${year}-${month}-${day}T${hours}:${minutes}`;
    console.log('setQuickAlarmTime3', alarmDateTime);
    alarmTimeInput.value = alarmDateTime;
}

function toggleRepeatInForm() { // For Add Form
    const repeatButton = document.getElementById('repeat-toggle');
    const repeatInput = document.getElementById('schedule-repeat');
    if (!repeatButton || !repeatInput) return;
    if (repeatInput.value === 'false') {
        repeatInput.value = 'true';
        repeatButton.textContent = '매일 반복 해제';
        repeatButton.classList.add('active');
    } else {
        repeatInput.value = 'false';
        repeatButton.textContent = '매일 반복';
        repeatButton.classList.remove('active');
    }
}

function cancelAddSchedule() {
    const form = document.querySelector('.add-schedule-form');
    if (form) form.remove();
}

async function handleAddSchedule(e) {
    e.preventDefault();
    const token = localStorage.getItem('token');
    if (!token) return;

    function formatDateTimeForAPI(dateStr) {
        if (!dateStr) return null;
        const date = new Date(dateStr);
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
    }

    const projectInput = document.getElementById('schedule-project');
    const titleInput = document.getElementById('schedule-title');
    const project = projectInput.value.trim() || '일정';
    const title = titleInput.value.trim() || '일정';
    const date = document.getElementById('schedule-date').value;
    const priority = document.getElementById('schedule-priority').value;
    if (!date || !priority) {
        alert('날짜와 우선순위는 필수 입력 항목입니다.'); return;
    }

    // 부모 ID와 parent_order 가져오기
    const parentIdInput = document.getElementById('parent-id');
    const parentOrderInput = document.getElementById('parent-order');
    const parent_id = parentIdInput && parentIdInput.value ? parseInt(parentIdInput.value) : null;
    const parent_order = parentOrderInput && parentOrderInput.value ? parseInt(parentOrderInput.value) : 0;

    // 새로운 프로젝트명인 경우 projects.json에 추가
    if (project !== '일정') {
        try {
            const response = await fetch('/projects/', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: project })
            });
            if (!response.ok) {
                const error = await response.json();
                // 이미 존재하는 프로젝트명인 경우는 무시
                if (error.detail !== "이미 존재하는 프로젝트입니다") {
                    throw new Error(error.detail);
                }
            }
        } catch (error) {
            log('ERROR', 'Add project error', error);
            // 프로젝트 추가 실패는 일정 생성에 영향을 주지 않도록 함
        }
    }

    const scheduleData = {
        project_name: project,
        title: title,
        date: formatDateTimeForAPI(date),
        priority: priority,
        content: document.getElementById('schedule-content').value || null,
        due_time: formatDateTimeForAPI(document.getElementById('schedule-due-time').value),
        alarm_time: formatDateTimeForAPI(document.getElementById('schedule-alarm-time').value),
        is_repeat: document.getElementById('schedule-repeat').value === 'true',
        parent_id: parent_id,
        parent_order: parent_order
    };

    try {
        const response = await fetch('/schedules/', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(scheduleData),
        });
        if (response.ok) {
            cancelAddSchedule();
            await refreshSchedules();
            // 프로젝트 목록 새로고침
            await loadProjectList();
        } else {
            const error = await response.json();
            log('ERROR', 'Schedule creation error', error);
            alert(error.detail || '일정 추가에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Add schedule error', error);
        alert('일정 추가 중 오류가 발생했습니다.');
    }
}

// Provided editSchedule by user
async function editSchedule(scheduleId) {
    const schedule = schedules.find(s => s.id === scheduleId);
    if (!schedule) { log('ERROR', `Schedule with id ${scheduleId} not found for editing.`); return; }
 
    const modal = document.querySelector('.schedule-modal');
    if (!modal) {
        alert("오류: 수정 대상 모달을 찾을 수 없습니다.");
        return;
    }
 
    const form = document.createElement('div');
    form.className = 'edit-form';
    
    const scheduleDate = schedule.date ? new Date(schedule.date).toISOString().split('T')[0] : '';
    const scheduleDueTime = schedule.due_time ? new Date(schedule.due_time).toISOString().slice(0, 16) : '';
    const scheduleAlarmTime = schedule.alarm_time ? new Date(schedule.alarm_time).toISOString().slice(0, 16) : '';

    form.innerHTML = `
        <form id="internal-edit-schedule-form">
            <h4>일정 수정</h4>
            <div class="form-group">
                <label for="edit-title">제목 *</label>
                <input type="text" id="edit-title" value="${schedule.title}" required>
            </div>
            <div class="form-group">
                <label for="edit-date">날짜 *</label>
                <input type="date" id="edit-date" value="${scheduleDate}" required>
            </div>
            <div class="form-group">
                <label for="edit-priority">우선순위 *</label>
                <select id="edit-priority" required>
                    <option value="긴급" ${schedule.priority === '긴급' ? 'selected' : ''}>긴급</option>
                    <option value="급함" ${schedule.priority === '급함' ? 'selected' : ''}>급함</option>
                    <option value="곧임박" ${schedule.priority === '곧임박' ? 'selected' : ''}>곧임박</option>
                    <option value="일반" ${schedule.priority === '일반' ? 'selected' : ''}>일반</option>
                    <option value="거북이" ${schedule.priority === '거북이' ? 'selected' : ''}>🐢 거북이</option>
                </select>
            </div>
            <div class="form-group">
                <label for="edit-content">내용</label>
                <textarea id="edit-content">${schedule.content || ''}</textarea>
            </div>
            <div class="form-group">
                <label for="edit-due-time">마감시간</label>
                <input type="datetime-local" id="edit-due-time" value="${scheduleDueTime}">
            </div>
            <div class="form-group">
                <label for="edit-alarm-time">알람시간</label>
                <input type="datetime-local" id="edit-alarm-time" value="${scheduleAlarmTime}">
            </div>
            <button type="submit">저장</button>
            <button type="button" onclick="cancelEdit(${scheduleId})">취소</button>
        </form>
    `;
 
    // *** 이 부분을 제거 - 상세 정보를 숨기지 않음 ***
    // const scheduleDetailDiv = modal.querySelector('.schedule-detail');
    // if (scheduleDetailDiv) scheduleDetailDiv.style.display = 'none';
 
    // 액션 버튼만 수정 모드용으로 변경
    const scheduleActionsDiv = modal.querySelector('.schedule-actions');
    if (scheduleActionsDiv) {
        scheduleActionsDiv.innerHTML = `
            <button onclick="deleteSchedule(${schedule.id})" class="clear-all-btn">삭제</button>
            <button onclick="shareSchedule(${schedule.id})">공유</button>
            <button onclick="cancelEdit(${scheduleId})">수정 취소</button> 
        `;
    }
 
    const modal_header = modal.querySelector('.modal-content');
    const modalBody = modal.querySelector('.schedule-detail');
    if (modal_header) {
        const existingEditForm = modal_header.querySelector('.edit-form');
        if (existingEditForm) existingEditForm.remove();
        modal_header.appendChild(form); // 상세 정보 아래에 수정 폼 추가
        //hide modalBody
        modalBody.style.display = 'none';
    } else {
        alert("수정 폼을 표시하는데 실패했습니다.");
        return;
    }
 
    form.querySelector('#internal-edit-schedule-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        await updateSchedule(scheduleId);
    });
}

// cancelEdit from backup
function cancelEdit(scheduleId) {
    const modal = document.querySelector('.schedule-modal');
    if (!modal) return;
    
    const editForm = modal.querySelector('.edit-form');
    if (editForm) editForm.remove();

    const schedule = schedules.find(s => s.id === scheduleId);
    if (!schedule) return;

    const scheduleActionsDiv = modal.querySelector('.schedule-actions');
    const modalBody = modal.querySelector('.schedule-detail');
    if (modalBody) modalBody.style.display = 'block';
    if (scheduleActionsDiv) {
        scheduleActionsDiv.innerHTML = `
            <button onclick="editSchedule(${schedule.id})">수정</button>
            <button onclick="shareSchedule(${schedule.id})">공유</button>
            <button onclick="toggleComplete(${schedule.id}, ${!schedule.is_completed})">
                ${schedule.is_completed ? '미완료로' : '완료로'}
            </button>
            <button onclick="deleteSchedule(${schedule.id})" class="clear-all-btn">삭제</button>
        `;
    }
}

// updateSchedule from backup
async function updateSchedule(scheduleId) {
    const token = localStorage.getItem('token');
    if (!token) return;

    function formatDateTimeForAPI(dateStr) {
        if (!dateStr) return null;
        const date = new Date(dateStr);
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
    }

    const updatedData = {
        title: document.getElementById('edit-title').value,
        date: formatDateTimeForAPI(document.getElementById('edit-date').value),
        priority: document.getElementById('edit-priority').value,
        content: document.getElementById('edit-content').value || null,
        due_time: formatDateTimeForAPI(document.getElementById('edit-due-time').value),
        alarm_time: formatDateTimeForAPI(document.getElementById('edit-alarm-time').value),
    };

    try {
        const response = await fetch(`/schedules/${scheduleId}`, {
            method: 'PUT',
            headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(updatedData),
        });
        if (response.ok) {
            closeScheduleModal();
            await refreshSchedules();
        } else {
            const error = await response.json();
            log('ERROR', 'Failed to update schedule', error);
            alert(error.detail || '일정 수정에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Update schedule error', error);
        alert('일정 수정 중 오류가 발생했습니다.');
    }
}

async function deleteSchedule(scheduleId) {
    if (!confirm('정말로 이 일정을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) return;
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        const response = await fetch(`/schedules/${scheduleId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            closeScheduleModal();
            await refreshSchedules(); // 목록 새로고침
            alert('일정이 삭제되었습니다.');
        } else {
            const error = await response.json();
            log('ERROR', 'Failed to delete schedule', error);
            alert(error.detail || '일정 삭제에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Delete schedule error', error);
        alert('일정 삭제 중 오류가 발생했습니다.');
    }
}

// shareSchedule and shareScheduleWithUser from backup
async function shareSchedule(scheduleId) {
    const token = localStorage.getItem('token');
    if (!token) return;

    try {
        const usersResponse = await fetch('/users/', {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (!usersResponse.ok) throw new Error('Failed to fetch users for sharing.');
        
        const users = await usersResponse.json();
        const currentUserData = JSON.parse(localStorage.getItem('userData'));
        const otherUsers = users.filter(user => user.id !== currentUserData.id);

        if (otherUsers.length === 0) {
            alert('공유할 다른 사용자가 없습니다.'); return;
        }

        const modalBody = document.querySelector('.schedule-modal .modal-body');
        if (!modalBody) { alert('공유 폼을 표시할 위치를 찾지 못했습니다.'); return; }

        // 기존 공유 폼 제거
        const existingShareForm = modalBody.querySelector('.share-schedule-form-container');
        if (existingShareForm) existingShareForm.remove();

        const formContainer = document.createElement('div');
        formContainer.className = 'share-schedule-form-container'; // For styling and removal
        formContainer.innerHTML = `
            <form id="internal-share-schedule-form">
                <h4>일정 공유</h4>
                <div class="form-group">
                    <label for="share-user">공유할 사용자</label>
                    <select id="share-user" required>
                        ${otherUsers.map(user => `<option value="${user.id}">${user.name} (${user.username})</option>`).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label for="share-memo">메모 (선택)</label>
                    <textarea id="share-memo" placeholder="공유 시 전달할 메모"></textarea>
                </div>
                <div class="form-buttons">
                    <button type="submit">공유 실행</button>
                    <button type="button" onclick="this.closest('.share-schedule-form-container').remove()">취소</button>
                </div>
            </form>
        `;
        // 상세정보와 액션버튼 사이에 폼 삽입 또는 특정 위치에 append
        const scheduleDetailDiv = modalBody.querySelector('.schedule-detail');
        if (scheduleDetailDiv) {
            scheduleDetailDiv.parentNode.insertBefore(formContainer, scheduleDetailDiv.nextSibling); // 상세정보 다음에 삽입
        } else {
            modalBody.appendChild(formContainer); // fallback
        }
        
        formContainer.querySelector('#internal-share-schedule-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            await shareScheduleWithUser(scheduleId);
            formContainer.remove(); // 성공 여부와 관계없이 폼 제거
        });

    } catch (error) {
        log('ERROR', 'Share schedule setup error', error);
        alert('공유 기능 준비 중 오류가 발생했습니다: ' + error.message);
    }
}

async function shareScheduleWithUser(scheduleId) {
    const token = localStorage.getItem('token');
    if (!token) return;
    const sharedWithId = document.getElementById('share-user').value;
    const memo = document.getElementById('share-memo').value || null;

    const shareData = {
        schedule_id: scheduleId, // API 스키마에 따라 필드명 확인
        shared_with_id: parseInt(sharedWithId),
        memo: memo
    };
    log('DEBUG', 'Sharing schedule data', shareData);

    try {
        // API 엔드포인트: /schedules/{schedule_id}/share 또는 /shares/
        const response = await fetch(`/schedules/${scheduleId}/share`, { 
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(shareData),
        });
        if (response.ok) {
            alert('일정이 성공적으로 공유되었습니다.');
            // 공유 후 특별한 UI 변경이 필요하면 여기에 추가 (예: 알림 생성)
        } else if (response.status === 404 && (await response.json()).detail === "Share endpoint not implemented yet") {
            alert("공유 기능이 아직 구현되지 않았습니다.");
        }
         else {
            const error = await response.json();
            log('ERROR', 'Failed to share schedule', error);
            alert(error.detail || '일정 공유에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Share schedule execution error', error);
        alert('일정 공유 중 오류가 발생했습니다.');
    }
}

// showMemoPopup and updateMemo from backup
function showMemoPopup(scheduleId) {
    hideContextMenu(); // 컨텍스트 메뉴는 닫기
    const schedule = schedules.find(s => s.id === scheduleId);
    if (!schedule) { alert('메모를 추가할 일정을 찾지 못했습니다.'); return;}

    // 기존 메모 모달이 있다면 제거
    const existingMemoModal = document.querySelector('.memo-modal-overlay');
    if (existingMemoModal) existingMemoModal.remove();

    const memoModalOverlay = document.createElement('div');
    memoModalOverlay.className = 'memo-modal-overlay'; // 전체 화면 어둡게
    
    memoModalOverlay.innerHTML = `
        <div class="memo-modal-content">
            <div class="modal-header">
                <h3>메모 추가</h3>
                <button class="close-button" onclick="this.closest('.memo-modal-overlay').remove()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="internal-memo-form">
                    <div class="form-group">
                        <label for="memo-text-content">메모 내용</label>
                        <textarea id="memo-text-content" rows="5" placeholder="여기에 메모를 입력하세요..."></textarea>
                    </div>
                    <div class="form-buttons">
                        <button type="submit">추가</button>
                        <button type="button" onclick="this.closest('.memo-modal-overlay').remove()">취소</button>
                    </div>
                </form>
            </div>
        </div>
    `;
    
    // 일정 추가 버튼 찾기
    const addScheduleBtn = document.querySelector('.add-schedule-btn');
    if (addScheduleBtn) {
        // 일정 추가 버튼 다음에 메모 모달 삽입
        addScheduleBtn.parentNode.insertBefore(memoModalOverlay, addScheduleBtn.nextSibling);
    } else {
        // 일정 추가 버튼을 찾지 못한 경우 body에 추가
        document.body.appendChild(memoModalOverlay);
    }
    
    memoModalOverlay.querySelector('#internal-memo-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        await updateMemo(scheduleId);
    });
    document.getElementById('memo-text-content').focus(); // textarea에 포커스
}

async function updateMemo(scheduleId) {
    const token = localStorage.getItem('token');
    if (!token) return;
    const memoContent = document.getElementById('memo-text-content').value;
    if (!memoContent.trim()) return;

    const now = getCurrentTime();
    const formattedDate = now.toLocaleDateString('ko-KR', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit'
    }).replace(/\./g, '').replace(/\s/g, '');

    const currentUserData = JSON.parse(localStorage.getItem('userData'));
    const userName = currentUserData ? currentUserData.name : '알 수 없음';

    const newMemoLine = `${formattedDate} (${userName}) : ${memoContent}`;

    try {
        // 기존 메모 가져오기
        const schedule = schedules.find(s => s.id === scheduleId);
        const existingMemo = schedule ? schedule.memo : '';
        
        // 기존 메모가 있으면 줄바꿈 추가
        const combinedMemo = existingMemo ? `${existingMemo}\n${newMemoLine}` : newMemoLine;

        const response = await fetch(`/schedules/${scheduleId}/memo`, {
            method: 'PUT',
            headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ memo: combinedMemo }),
        });
        
        const data = await response.json();
        
        if (response.ok) {
            const memoModalOverlay = document.querySelector('.memo-modal-overlay');
            if (memoModalOverlay) memoModalOverlay.remove();
            
            // 스케줄 목록 실시간 업데이트 또는 모달 내용 업데이트
            const scheduleIndex = schedules.findIndex(s => s.id === scheduleId);
            if (scheduleIndex !== -1) {
                schedules[scheduleIndex].memo = data.memo;
            }
            // 현재 열려있는 상세 모달이 있다면 해당 모달도 업데이트
            const detailModal = document.querySelector('.schedule-modal[data-schedule-id="'+scheduleId+'"]');
            if (detailModal) {
                const memoDiv = detailModal.querySelector('.memo-content');
                if (memoDiv) {
                    memoDiv.innerHTML = data.memo ? data.memo.split('\n').map(line => `<div>${line}</div>`).join('') : '없음';
                }
            }
            renderSchedules();
        } else {
            log('ERROR', 'Failed to update memo', data);
            alert(data.detail || '메모 추가에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Update memo error', error);
        alert('메모 추가 중 오류가 발생했습니다.');
    }
}

// User Filtering Functions
async function loadUserCheckboxes() {
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        const response = await fetch('/users/', {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            const users = await response.json();
            const container = document.getElementById('user-checkboxes');
            if (!container) return;
            container.innerHTML = ''; // Clear previous
            // "전체 사용자" 옵션 추가
            const allUsersDiv = document.createElement('div');
            allUsersDiv.className = 'user-checkbox';
            allUsersDiv.innerHTML = `
                <input type="checkbox" id="user-all" value="all" onchange="toggleAllUsersFilter(this.checked)" ${selectedUsers.size === 0 ? 'checked' : ''}>
                <label for="user-all">모든 사용자</label>
            `;
            container.appendChild(allUsersDiv);

            users.forEach(user => {
                const div = document.createElement('div');
                div.className = 'user-checkbox';
                div.innerHTML = `
                    <input type="checkbox" id="user-${user.id}" value="${user.id}" 
                           onchange="toggleUserFilter(${user.id}, this.checked)"
                           ${selectedUsers.has(user.id) ? 'checked' : ''}>
                    <label for="user-${user.id}">${user.name} (${user.username})</label>
                `;
                container.appendChild(div);
            });
        } else {
             log('ERROR', 'Failed to load users for filter', {status: response.status});
        }
    } catch (error) {
        log('ERROR', 'Load users filter error', error);
    }
}

function toggleAllUsersFilter(checked) {
    const userCheckboxes = document.querySelectorAll('#user-checkboxes input[type="checkbox"]:not(#user-all)');
    if (checked) {
        selectedUsers.clear();
        userCheckboxes.forEach(cb => cb.checked = false);
    }
    // "모든 사용자"가 체크되면 다른 필터는 의미 없음 (백엔드에서 user_ids 파라미터 없이 요청)
    // 만약 "모든 사용자" 체크 해제 시, 어떤 동작을 할지 정의 필요 (예: 이전에 선택된 사용자 복원 또는 아무것도 안함)
    // 여기서는 "모든 사용자" 체크 시 다른 사용자 선택 해제하고, selectedUsers 비움.
    refreshSchedules();
    updateUserFilterCheckboxes();
}

function toggleUserFilter(userId, checked) {
    if (checked) {
        selectedUsers.add(userId);
    } else {
        selectedUsers.delete(userId);
    }
    // 다른 사용자 필터가 선택되면 "모든 사용자"는 자동 해제
    const allUserCb = document.getElementById('user-all');
    if (allUserCb) allUserCb.checked = selectedUsers.size === 0;
    
    refreshSchedules();
    updateUserFilterCheckboxes(); // 체크박스 상태 동기화
}

function updateUserFilterCheckboxes() {
    const allUserCb = document.getElementById('user-all');
    if (allUserCb) {
        allUserCb.checked = selectedUsers.size === 0;
    }
    document.querySelectorAll('#user-checkboxes input[type="checkbox"]:not(#user-all)').forEach(cb => {
        cb.checked = selectedUsers.has(parseInt(cb.value));
    });
}


// --- ALARM FUNCTIONS ---
let alarmPollingInterval = null;
let alarms = [];

async function loadAlarms() {
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        const response = await fetch('/alarms', { // API 엔드포인트 확인
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            const newAlarms = await response.json();
            if (JSON.stringify(alarms) !== JSON.stringify(newAlarms)) { // 변경이 있을 때만 렌더링
                alarms = newAlarms;
                renderAlarms();
            }
        } else if (response.status === 401) {
            clearSession(); // 토큰 만료 등
        } else {
            log('WARN', 'Failed to load alarms', { status: response.status });
            // renderAlarms(); // 빈 목록 또는 오류 메시지 표시
        }
    } catch (error) {
        log('ERROR', 'Load alarms error', error);
        // renderAlarms();
    }
}

// renderAlarms 함수 수정 - 미확인 알람 체크 기능 추가
function renderAlarms() {
    const alarmListDiv = document.getElementById('alarm-list');
    if (!alarmListDiv) return;
    alarmListDiv.innerHTML = '';
    
    // 미확인 알람 개수 체크
    const unackedCount = alarms.filter(alarm => !alarm.is_acked).length;
    updateAlarmIndicator(unackedCount);
    
    if (alarms.length === 0) {
        alarmListDiv.innerHTML = '<div class="no-alarms">새로운 알람이 없습니다.</div>';
        return;
    }
    alarms.slice().sort((a,b) => new Date(b.created_at) - new Date(a.created_at)).forEach(alarm => { // 최신순 정렬
        const alarmDiv = document.createElement('div');
        alarmDiv.className = `alarm-item ${alarm.type} ${alarm.is_acked ? 'acked' : 'unacked'}`;
        const createdTime = new Date(alarm.created_at).toLocaleString('ko-KR', {
            month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
        });
        alarmDiv.innerHTML = `
            <div class="alarm-content">
                <span class="alarm-type-badge">${getAlarmTypeText(alarm.type)}</span>
                <span class="alarm-message">${alarm.message}</span>
                <span class="alarm-time">${createdTime}</span>
                
            </div>
            <div class="alarm-actions">
                ${!alarm.is_acked ? `<button onclick="ackAlarm(${alarm.id})" class="ack-btn" title="확인됨으로 표시">✔️</button>` : `<span class="acked-mark" title="확인됨">✅</span>`}
                <button onclick="deleteAlarm(${alarm.id})" class="delete-btn" title="알람 삭제">🗑️</button>
                ${alarm.type === 'memo' ? `<button onclick="goToScheduleMemo(${alarm.schedule_id})" class="memo-link-btn">열기</button>` : ''}
            </div>
        `;
        alarmListDiv.appendChild(alarmDiv);
    });
}

// 메모로 이동하는 함수
function goToScheduleMemo(scheduleId) {
    // 해당 일정의 테이블 행 찾기
    const scheduleRow = document.querySelector(`tr[data-schedule-id="${scheduleId}"]`);
    if (!scheduleRow) {
        // data-schedule-id 속성이 없는 경우, 일정 목록에서 해당 ID를 가진 일정 찾기
        const schedule = schedules.find(s => s.id === scheduleId);
        if (schedule) {
            // 일정 모달 열기
            handleScheduleClick(schedule);
            // 스크롤 위치 조정
            const scheduleContainer = document.querySelector('.schedule-container');
            if (scheduleContainer) {
                const scheduleIndex = schedules.findIndex(s => s.id === scheduleId);
                if (scheduleIndex !== -1) {
                    const rowHeight = 40; // 예상되는 행 높이
                    const scrollPosition = scheduleIndex * rowHeight;
                    scheduleContainer.scrollTo({
                        top: scrollPosition,
                        behavior: 'smooth'
                    });
                }
            }
        }
    } else {
        // 행이 있는 경우 해당 행으로 스크롤
        scheduleRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // 일정 모달 열기
        const schedule = schedules.find(s => s.id === scheduleId);
        if (schedule) {
            handleScheduleClick(schedule);
        }
    }
}

// 새로운 함수: 알람 인디케이터 업데이트
function updateAlarmIndicator(unackedCount) {
    const alarmCollapsible = document.getElementById('alarm-collapsible');
    const alarmHeaderCollapsible = alarmCollapsible?.querySelector('.alarm-header-collapsible');
    
    if (!alarmHeaderCollapsible) return;
    
    // 기존 인디케이터 제거
    const existingIndicator = alarmHeaderCollapsible.querySelector('.unacked-indicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }
    
    if (unackedCount > 0) {
        // 미확인 알람 개수 표시
        const indicator = document.createElement('span');
        indicator.className = 'unacked-indicator';
        indicator.textContent = unackedCount;
        
        const h3 = alarmHeaderCollapsible.querySelector('h3');
        h3.appendChild(indicator);
        
        // 깜빡임 효과 시작
        alarmCollapsible.classList.add('has-unacked-alarms');
    } else {
        // 깜빡임 효과 제거
        alarmCollapsible.classList.remove('has-unacked-alarms');
    }
}

function getAlarmTypeText(type) {
    const map = { 'schedule_due': '일정만료', 'memo': '새메모', 'share': '공유됨', 'completion_request': '완료요청', 'new_schedule': '새일정' };
    return map[type] || type;
}

// ackAlarm과 deleteAlarm 함수 수정하여 인디케이터 업데이트
async function ackAlarm(alarmId) {
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        const response = await fetch(`/ack_alarms/${alarmId}/ack`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            await loadAlarms(); // 목록 새로고침 (renderAlarms에서 인디케이터도 업데이트됨)
        } else {
             log('ERROR', 'Failed to ack alarm', {status: response.status});
             alert('알람 확인 처리에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Ack alarm error', error);
        alert('알람 확인 처리 중 오류 발생.');
    }
}



async function deleteAlarm(alarmId) {
    // 확인 없이 바로 삭제 또는 confirm 추가
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        const response = await fetch(`/delete_alarms/${alarmId}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            await loadAlarms(); // 목록 새로고침 (renderAlarms에서 인디케이터도 업데이트됨)
        } else {
            log('ERROR', 'Failed to delete alarm', {status: response.status});
            alert('알람 삭제에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Delete alarm error', error);
        alert('알람 삭제 중 오류 발생.');
    }
}

async function clearAllAlarms() {
    if (!confirm('읽은 알람을 포함하여 모든 알람을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) return;
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        const response = await fetch('/clear_alarms/clear', { // 엔드포인트 확인 /clear_alarms/clear 또는 /alarms/clear_all
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            await loadAlarms(); // 목록 새로고침 (renderAlarms에서 인디케이터도 업데이트됨)
            alert('모든 알람이 삭제되었습니다.');
        } else {
            log('ERROR', 'Failed to clear all alarms', {status: response.status});
            alert('모든 알람 삭제에 실패했습니다.');
        }
    } catch (error) {
        log('ERROR', 'Clear all alarms error', error);
        alert('모든 알람 삭제 중 오류 발생.');
    }
}

function startAlarmPolling() {
    stopAlarmPolling(); // 기존 인터벌이 있다면 중지
    loadAlarms(); // 즉시 한번 로드
    alarmPollingInterval = setInterval(loadAlarms, 30000); // 30초마다
    log('INFO', 'Alarm polling started.');
}

function stopAlarmPolling() {
    if (alarmPollingInterval) {
        clearInterval(alarmPollingInterval);
        alarmPollingInterval = null;
        log('INFO', 'Alarm polling stopped.');
    }
}

// --- BROWSER NOTIFICATIONS (for schedule due times) ---
// (이 부분은 백업 파일에 있던 setInterval(checkScheduleAlarms, 60000)과 유사)
function checkScheduleAlarmsForNotification() {
    const now = getCurrentTime();
    schedules.forEach(schedule => {
        if (schedule.alarm_time && !schedule.is_completed) {
            const alarmTime = new Date(schedule.alarm_time);
            // 알람 시간이 현재 시간 이전이고, 마지막 알림 체크 시간보다 이후인 경우 알림 (중복 방지)
            if (alarmTime <= now && (!schedule.last_notified_at || new Date(schedule.last_notified_at) < alarmTime)) {
                showBrowserNotification('일정 알림: ' + schedule.title, schedule.content || '세부 내용 없음');
                schedule.last_notified_at = now.toISOString(); // 알림 발생 시간 기록 (클라이언트 사이드)
            }
        }
    });
}
// 주기적으로 체크
// setInterval(checkScheduleAlarmsForNotification, 60000); // 1분마다

function showBrowserNotification(title, body) {
    if (!("Notification" in window)) {
        log('WARN', 'Browser does not support notifications.');
        return;
    }
    if (Notification.permission === "granted") {
        new Notification(title, { body, icon: '/icon.png' }); // 아이콘 경로 추가 가능
    } else if (Notification.permission !== "denied") {
        Notification.requestPermission().then(permission => {
            if (permission === "granted") {
                new Notification(title, { body, icon: '/icon.png' });
            }
        });
    }
}
// 페이지 로드 시 알림 권한 요청 (선택적)
// document.addEventListener('DOMContentLoaded', () => {
//     if (Notification.permission !== "granted" && Notification.permission !== "denied") {
//         Notification.requestPermission();
//     }
// });


// Global Error Handlers
window.addEventListener('error', (event) => {
    log('ERROR', 'Global error caught', {
        message: event.message, filename: event.filename,
        lineno: event.lineno, colno: event.colno, error: event.error
    });
});
window.addEventListener('unhandledrejection', (event) => {
    log('ERROR', 'Unhandled promise rejection', { reason: event.reason });
});

// 테스트용: 모든 일정 삭제 함수
async function deleteAllSchedules() {
    if (!confirm('정말로 모든 일정을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) return;
    
    const token = localStorage.getItem('token');
    if (!token) return;

    try {
        // 먼저 모든 일정 목록을 가져옵니다
        const response = await fetch('/schedules/', {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) {
            throw new Error('일정 목록을 가져오는데 실패했습니다.');
        }
        
        const schedules = await response.json();
        
        // 각 일정을 순차적으로 삭제
        for (const schedule of schedules) {
            const deleteResponse = await fetch(`/schedules/${schedule.id}`, {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${token}` }
            });
            
            if (!deleteResponse.ok) {
                console.error(`일정 ID ${schedule.id} 삭제 실패`);
            }
        }
        
        // 일정 목록 새로고침
        await refreshSchedules();
        alert('모든 일정이 삭제되었습니다.');
        
    } catch (error) {
        log('ERROR', 'Delete all schedules error', error);
        alert('일정 삭제 중 오류가 발생했습니다.');
    }
}

// 테스트용: 모든 일정 삭제 버튼 추가
function addDeleteAllButton() {
    const controls = document.querySelector('.controls');
    if (!controls) return;
    
    const deleteAllButton = document.createElement('button');
    deleteAllButton.textContent = '모든 일정 삭제';
    deleteAllButton.onclick = deleteAllSchedules;
    deleteAllButton.style.backgroundColor = '#dc3545'; // 빨간색 배경
    deleteAllButton.style.color = 'white';
    deleteAllButton.style.marginLeft = '10px';
    
    controls.appendChild(deleteAllButton);
}

async function loadProjectList() {
    const token = localStorage.getItem('token');
    if (!token) return;
    try {
        const response = await fetch('/projects/', {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
            const projects = await response.json();
            const projectInput = document.getElementById('schedule-project');
            const projectList = document.getElementById('project-list');
            if (projectList) {
                projectList.innerHTML = '';
                projects.forEach(project => {
                    const option = document.createElement('div');
                    option.className = 'project-option';
                    option.textContent = project.name;
                    option.onclick = () => {
                        projectInput.value = project.name;
                        projectList.style.display = 'none';
                    };
                    projectList.appendChild(option);
                });
            }
        }
    } catch (error) {
        log('ERROR', 'Load project list error', error);
    }
}

function renderControls() {
    const controlsDiv = document.querySelector('.controls');
    if (!controlsDiv) return;
    
    controlsDiv.innerHTML = `
        <button onclick="toggleCompletedFilter()">완료된 일정 ${showCompleted ? '숨기기' : '보기'}</button>
        <button onclick="toggleAllUsersFilter(!showAllUsers)">모든 사용자 ${showAllUsers ? '숨기기' : '보기'}</button>
        <button onclick="toggleCompletedOnly()">완료된 일정만 ${completedOnly ? '해제' : '보기'}</button>
        <button onclick="showDateRangeModal()" class="excel-export-btn">
            <i class="fas fa-file-excel"></i> 엑셀로 출력
        </button>
        <button onclick="showAddScheduleForm()" class="add-schedule-btn">일정 추가</button>
    `;
}

async function exportToExcel(startDate, endDate) {
    const token = localStorage.getItem('token');
    if (!token) {
        alert('로그인이 필요합니다.');
        return;
    }

    if (!startDate || !endDate) {
        alert('시작 날짜와 종료 날짜를 모두 선택해주세요.');
        return;
    }

    try {
        // 로딩 표시
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading-overlay';
        loadingDiv.innerHTML = '<div class="loading-spinner"></div><div>엑셀 파일 생성 중...</div>';
        document.body.appendChild(loadingDiv);

        // 날짜 형식 변환 (YYYY-MM-DD)
        const formattedStartDate = new Date(startDate).toISOString().split('T')[0];
        const formattedEndDate = new Date(endDate).toISOString().split('T')[0];

        const response = await fetch(`/schedules/export/excel?start_date=${formattedStartDate}&end_date=${formattedEndDate}`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || '엑셀 파일 생성에 실패했습니다.');
        }

        // 파일 다운로드
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `schedules_export_${formattedStartDate}_to_${formattedEndDate}.xlsx`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);

    } catch (error) {
        console.error('Export error:', error);
        alert(error.message || '엑셀 파일 생성 중 오류가 발생했습니다.');
    } finally {
        // 로딩 표시 제거
        const loadingDiv = document.querySelector('.loading-overlay');
        if (loadingDiv) {
            document.body.removeChild(loadingDiv);
        }
    }
}

function toggleCompletedOnly() {
    completedOnly = !completedOnly;
    refreshSchedules();
    renderControls();
}

function showDateRangeModal() {
    const modal = document.getElementById('date-range-modal');
    modal.style.display = 'block';
    
    // 오늘 날짜를 기본값으로 설정
    const today = new Date().toISOString().split('T')[0];
    const startDateInput = document.getElementById('start-date');
    const endDateInput = document.getElementById('end-date');
    
    // 이전에 선택한 날짜가 있으면 유지, 없으면 오늘 날짜로 설정
    startDateInput.value = startDateInput.value || today;
    endDateInput.value = endDateInput.value || today;
}

function closeDateRangeModal() {
    const modal = document.getElementById('date-range-modal');
    modal.style.display = 'none';
}

async function confirmExport() {
    const startDate = document.getElementById('start-date').value;
    const endDate = document.getElementById('end-date').value;
    
    if (!startDate || !endDate) {
        alert('시작 날짜와 종료 날짜를 모두 선택해주세요.');
        return;
    }
    
    if (new Date(startDate) > new Date(endDate)) {
        alert('시작 날짜는 종료 날짜보다 이후일 수 없습니다.');
        return;
    }
    
    await exportToExcel(startDate, endDate);
    closeDateRangeModal();
}