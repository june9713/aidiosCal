# Analysis 0018: 월간/주간 일정 시간 중복 조정 문제 분석

## 문제 개요
월간 일정과 주간 일정에서 스케줄 테이블의 일정 시간에 +9시간이 중복으로 적용되는 문제가 발생하고 있음. 이는 한국 시간대 처리 로직이 여러 곳에서 중복 적용되기 때문으로 추정됨.

## 시간 처리 흐름 분석

### 1. 서버 측 시간 처리
- **데이터베이스**: 스케줄 테이블의 `date`, `due_time` 필드에 시간 저장
- **API 응답**: `/schedules/` 엔드포인트에서 스케줄 목록 반환
- **시간 조정**: `/gettimenow` 엔드포인트에서 `time.time() + (9 * 3600)` 적용

### 2. 클라이언트 측 시간 처리
#### A. main.js의 시간 처리
- `koreaTimeOffset = 9 * 60 * 60 * 1000` (9시간을 밀리초로)
- 여러 함수에서 `new Date(now.getTime() + koreaTimeOffset)` 사용
- 시간 비교 및 표시 시 한국 시간으로 변환

#### B. calendar.js의 시간 처리
- `getSchedulesForDate()`: `new Date(schedule.date).toISOString().split('T')[0]` 로 날짜 비교
- `createWeeklyScheduleElement()`: `new Date(schedule.due_time)` 로 시간 계산

## 중복 적용 지점 추정

### 1. 데이터 저장 시점
- 클라이언트에서 일정 생성 시 한국 시간으로 변환하여 전송
- 서버에서 받은 시간을 그대로 데이터베이스에 저장

### 2. 데이터 조회 시점
- 서버에서 데이터베이스의 시간을 그대로 응답
- 클라이언트에서 받은 시간을 다시 한국 시간으로 변환

### 3. 화면 표시 시점
- 월간/주간 달력에서 시간 계산 시 추가 변환 적용

## 디버깅 로그 추가 영역

### 서버 측 로그
- `app/routers/schedules.py`: 스케줄 조회 시 시간 정보 로깅
- 필터링 과정에서 날짜 비교 로깅

### 클라이언트 측 로그
- `static/js/calendar.js`: 
  - 스케줄 로드 시 원본 데이터 로깅
  - 날짜별 필터링 과정 로깅
  - 주간 달력 시간 계산 과정 로깅
- `static/js/main.js`:
  - 날짜 포맷팅 과정 로깅
  - 시간 비교 과정 로깅

## 예상 해결 방안
1. **일관된 시간 기준 설정**: UTC 또는 한국 시간 중 하나로 통일
2. **중복 변환 제거**: 서버-클라이언트 간 시간 처리 로직 일원화
3. **명확한 시간대 정의**: 각 필드가 어떤 시간대를 나타내는지 명확히 정의

## 주의사항
- 기존 데이터의 시간대 일관성 확인 필요
- 수정 시 모든 시간 관련 기능에 영향 검토 필요
- 알람 기능과의 연동 고려 필요 